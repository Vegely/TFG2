\chapter{Desarrollo}
En este capítulo se describe el código y la implementación propia realizada en base a los algoritmos proporcionados por el \acrshort{nist}.
\section{Adaptación de Primitivas Criptográficas} La primera fase del desarrollo se centró en la extracción y depuración de los núcleos algorítmicos en lenguaje C, con el objetivo de garantizar su portabilidad independientemente de la plataforma escogida.
\newline

Las implementaciones de referencia presentan dependencias de compilación ligadas a entornos UNIX, presencia de trazas de depuración (\textit{debug prints}) dispersas en múltiples ficheros y cierto acoplamiento entre la lógica criptográfica y los vectores de prueba.  Por ello, en esta sección se detallan las refactorizaciones realizadas y se describe la estructura final de los ficheros fuente para cada algoritmo.

\subsection{Kyber y Saber: Implementaciones de Referencia}
Para los algoritmos Kyber y Saber se han integrado las implementaciones de referencia presentadas por los autores en las rondas 3 y 4 del \acrshort{nist} \cite{nistPQCround3} \cite{nistPQCround4}. 
\newline

Se han aplicado modificaciones estructurales menores, siendo la más relevante el desacoplamiento del módulo de generación de aleatoriedad. En la versión original, el código dependía de \texttt{rng.h} para generar secuencias deterministas a partir de una semilla fija. Esta dependencia se ha sustituido por la interfaz genérica \texttt{randombytes.h}, la cual permite inyectar una fuente de entropía real del sistema. Para más detalles sobre esta gestión de aleatoriedad, consultar la sección \ref{rng:win}.

\newpage
\subsubsection{Estructura del código en Kyber}
En la tabla \ref{tab:kyber_files} se describe brevemente la estructura lógica del código de Kyber tras la limpieza del código \cite{kyber-spec-2021}.



\begin{table}[H]
	\centering
	
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{kem, indcpa} & Implementan el protocolo de intercambio de claves. En \texttt{indcpa} se encuentran los esquemas básicos de la \acrshort{mlwe} para obtener seguridad \acrshort{cpa} mientras que en el fichero \texttt{kem} mediante la \acrshort{tfo} se implementa la seguridad \acrshort{cca22}. \\
			
			& \texttt{api}& Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{kyber\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de Kyber.  \\ 
			& \texttt{verify} & Función para comparar dos vectores en tiempo constante. \\ \addlinespace
			\textbf{Matemáticas} & \texttt{poly, polyvec} & Definen las estructuras de datos para operaciones algebraicas sobre el anillo $R_q$. \\
			& \texttt{ntt, reduce} & Implementan la multiplicación rápida de polinomios mediante la \acrshort{ntt} y la reducción modular eficiente (se usa un módulo no potencia de 2 \(q=3329\)). \\
			& \texttt{cbd} & Generación de ruido determinista necesario para la seguridad LWE mediante la distribución binomial. \\ \addlinespace
			
			\textbf{Hashing}     & \texttt{fips202, sha, symetric} & Implementación del estándar SHA-3 (Keccak) junto a las interfaces necesarias para kyber. \\
			 \addlinespace
			
			\textbf{Sistema}     
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			&\texttt{params}&Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de Kyber.}
	\label{tab:kyber_files}
\end{table}
\newpage
\subsubsection{Estructura del código en Saber}
En la tabla \ref{tab:saber_files} se describe brevemente la estructura lógica del código de Saber tras la limpieza del código \cite{saber-spec-2020}.
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{kem, SABER\_indcpa} & Implementan el mecanismo de encapsulamiento. En \texttt{SABER\_indcpa} se define la lógica base del problema \acrshort{mlwr}  para seguridad \acrshort{cpa}, mientras que \texttt{kem} aplica la \acrshort{tfo} para alcanzar seguridad \acrshort{cca22}. \\
			& \texttt{api} &  Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{saber\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de Saber.  \\ 
			& \texttt{verify} & Función auxiliar para comparación de vectores en tiempo constante. \\ \addlinespace
			
			\textbf{Matemáticas} & \texttt{poly, pack\_unpack} & Estructuras de datos para el anillo $R_q$ y rutinas de optimización del ancho de banda. \\
			& \texttt{poly\_mul} & Implementa la multiplicación polinomial mediante Toom-Cook y Karatsuba. \\
			& \texttt{cbd} & Generación de ruido determinista mediante la Distribución Binomial Centrada. \\ \addlinespace
			
			\textbf{Hashing} & \texttt{fips202} & Implementación del estándar SHA-3 (Keccak). \\ \addlinespace
			
			\textbf{Sistema} 
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			& \texttt{SABER\_params} & Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de Saber.}
	\label{tab:saber_files}
\end{table}
\subsection{HQC: Selección de PQClean}
Para \acrshort{hqc}, se descartó la implementación de la ronda 4 del NIST en favor de la versión mantenida por el proyecto PQClean \cite{pqclean_github} \cite{SSR:KSSW22}. Esta decisión se fundamenta en la arquitectura de la versión original, la cual presenta un fuerte acoplamiento con el generador pseudoaleatorio determinista diseñado para pruebas  \acrlong{kat}(\acrshort{kat}). La versión de PQClean ofrece una interfaz para modificar la fuente de aleatoriedad de manera sencilla. Esto facilita el uso de una semilla fija para validación o una fuente de aleatoriedad real (\acrshort{trng}).
\newline

Es importante señalar que la implementación actual no garantiza seguridad \acrshort{cca2}. Esto se debe a que, durante la fase de desencapsulado, el mecanismo de verificación carece de rechazo implícito. Si el texto cifrado recalculado no coincide con el recibido, la función retorna un fallo explícito en lugar de generar un valor pseudoaleatorio indistinguible para un atacante. Esta limitación ha sido asumida dentro del alcance del proyecto priorizando la claridad conceptual, ya que, aunque su inclusión afectaría marginalmente a las métricas de rendimiento, no compromete la validación funcional de los algoritmos. Si se quisiera implementar la solución para un entorno de producción sería necesario utilizar la \acrshort{tfo}.

\newpage

\subsubsection{Estructura del código en \acrshort{hqc}}
En la tabla \ref{tab:hqc_files} se describe brevemente la estructura lógica del código de \acrshort{hqc} tras la limpieza del código \cite{pqclean_github}.
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{code, hqc} & En \texttt{code} se define una interfaz a los mecanismos de corrección de errores, mientras que \texttt{hqc} implementa todo el mecanismo de intercambio de claves. \\
			& \texttt{api} & Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{hqc\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de HQC.  \\ 
			& \texttt{parsing} & Funciones auxiliares para dar formato a las claves y los textos cifrados. \\ \addlinespace
			
			\textbf{Matemáticas} & \texttt{reed\_solomon, reed\_muller} & Implementan la codificación y decodificación de códigos correctores de errores. \\
			& \texttt{gf, gf2x, fft} & Implementa la aritmética en cuerpos de Galois y multiplicación de polinomios eficiente mediante la Transformada Rápida de Fourier. \\
			& \texttt{vector} & Implementa la aritmética entre vectores de bits. \\ \addlinespace
			
			\textbf{Hashing} & \texttt{fips202, shake\_ds, shake\_prng} & Implementación del estándar SHA-3 (Keccak) junto a las interfaces necesarias para \acrshort{hqc}. \\  \addlinespace
			
			\textbf{Sistema} 
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			& \texttt{parameters, domains} & Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de \acrshort{hqc}.}
	\label{tab:hqc_files}
\end{table}
\section{Unificación de Interfaces (Capa Wrapper)}
Se ha desarrollado un módulo envoltorio (\textit{wrapper}) para cada algoritmo con el objetivo de encapsular las implementaciones de referencia del \acrshort{nist} \cite{nistPQCround3} \cite{nistPQCround4} bajo una interfaz común. La estructura general de los ficheros de cabecera, denominados \texttt{AlgorithmWrapper.h}, se detalla en el Listing \ref{lst:wrapper_core}.
\newline

El propósito principal de esta capa de abstracción es homogeneizar las distintas implementaciones provistas por el \acrshort{nist}. Esto permite instanciar los algoritmos mediante un inicializador común, configurado según el nivel de seguridad definido durante la compilación de la librería. Asimismo, este diseño resuelve los conflictos de enlazado (\textit{linking}) derivados del uso de símbolos idénticos en las APIs originales, facilitando así la intercambiabilidad dinámica entre los distintos algoritmos criptográficos.
\newline

Finalmente, en lo relativo a la gestión de memoria, se ha adoptado una filosofía donde la responsabilidad recae íntegramente en el usuario, quien debe encargarse de la asignación y liberación de los \textit{buffers}.
\newpage

\begin{lstlisting}[language=C, caption={Estructura genérica del wrapper para los algoritmos PQC}, label={lst:wrapper_core}]
	// Estructura comun para Kyber, HQC y Saber
	// Se sustituye "ALG" por el nombre del algoritmo especifico
	
	#include "alg_wrapper.h"
	#include "api.h" 
	
	// Nivel de seguridad actual (Estado interno)
	static alg_security_level_t current_security_level;
	static int is_initialized = 0;
	
	// Inicializacion del esquema
	int alg_init(alg_security_level_t security_level) {
		// Validacion del nivel de seguridad
		if (security_level != ALG_SEC_LEVEL_1 && 
		security_level != ALG_SEC_LEVEL_3 && 
		security_level != ALG_SEC_LEVEL_5) {
			return -1;
		}
		
		current_security_level = security_level;
		is_initialized = 1;
		return 0;
	}
	
	// Getters de tamaños (Wrappers directos a la API nativa)
	size_t alg_get_public_key_size(void) { return CRYPTO_PUBLICKEYBYTES; }
	size_t alg_get_secret_key_size(void) { return CRYPTO_SECRETKEYBYTES; }
	size_t alg_get_ciphertext_size(void) { return CRYPTO_CIPHERTEXTBYTES; }
	size_t alg_get_shared_secret_size(void) { return CRYPTO_BYTES; }
	
	// Generacion de claves
	int alg_keypair(unsigned char *pk, unsigned char *sk) {
		if (!is_initialized) return -1;
		return crypto_kem_keypair(pk, sk);
	}
	
	// Encapsulamiento
	int alg_encapsulate(unsigned char *ct, unsigned char *ss, const unsigned char *pk) {
		if (!is_initialized) return -1;
		return crypto_kem_enc(ct, ss, pk);
	}
	
	// Desencapsulamiento
	int alg_decapsulate(unsigned char *ss, const unsigned char *ct, const unsigned char *sk) {
		if (!is_initialized) return -1;
		return crypto_kem_dec(ss, ct, sk);
	}
\end{lstlisting}


\section{Precompilados y gestión de la aleatoriedad.}
\label{rng:win}
Para agilizar la integración de los algoritmos de cifrado en sistemas de propósito general, se ha optado por encapsular la lógica en bibliotecas estáticas (.lib). Gracias a esto, la interacción a nivel de usuario se reduce al uso de una interfaz simplificada, similar a la mostrada en el Listing \ref{lst:wrapper_core}, facilitando su incorporación en proyectos externos.
\newline

Es importante señalar que, debido a la arquitectura actual, la selección del nivel de seguridad es estática. Para alternar dinámicamente entre distintos niveles, sería necesario refactorizar el código para desacoplarlo de los archivos de parámetros dependientes de la compilación al incluirlos en el init de los algoritmos. Sin embargo, dado que el alcance de este trabajo se centra en el análisis de algoritmos con un nivel de seguridad equivalente a 256 bits, no se ha considerado prioritaria dicha flexibilidad en esta etapa.
\newline


En cuanto a la gestión de aleatoriedad, como se mencionó anteriormente, existen dos implementaciones en función de la función que se desea que cumpla el algoritmo:
\begin{itemize}
	\item \textbf{Versión determinista (\texttt{rng.h}):} Utilizada para generar vectores de prueba conocidos (\acrshort{kat}). Genera los secretos compartidos a partir de una semilla inicial fija. Esta implementación inicializa la entropía con un valor conocido y utiliza \texttt{AES256} para derivar una secuencia de números pseudoaleatorios, permitiendo así la verificación mediante archivos \texttt{.req} y \texttt{.rsp}.
	
	\item \textbf{Versión de producción (\texttt{randombytes.h}):} Implementa un generador de números aleatorios criptográficamente seguro. En sistemas de propósito general, se obtiene la entropía directamente del sistema operativo, mientras que en la plataforma PSOC utiliza el generador de hardware (\acrshort{trng}) nativo de la placa.

	\newline
	Para la implementación en sistemas de propósito general se ha integrado la librería disponible en \cite{sprenkels_randombytes_2017}, utilizada también en el proyecto PQClean \cite{SSR:KSSW22}. De este modo, se garantiza el uso de un generador criptográficamente seguro, cumpliendo con los requisitos de seguridad que serán validados posteriormente mediante baterías de tests estadísticos.
	
\end{itemize}


\section{Arquitectura del Agente Criptográfico y de las comunicaciones (C++)}
Sobre la base de las librerías en C descritas anteriormente, se ha construido una capa de aplicación en C++ que integra las capacidades criptográficas con un módulo de comunicaciones serie.

\subsection{Modelo de comunicaciones}
Para implementar las comunicaciones, por su sencillez se ha optado por la comunicación mediante UART conectando directamente la placa del PSOC al ordenador por USB. Los parámetros generales de las comunicaciones utilizados son:
\begin{itemize}
	\item \textbf{BaudRate:} 115200 baudios.
	\item \textbf{Data Bits:} 8 bits.
	\item \textbf{Paridad:} Ninguna (\textit{No Parity}).
	\item \textbf{Bits de parada:} 1 bit.
	\item \textbf{Control de flujo:} Ninguno. La gestión de la integridad se delega a los buffers de software, aunque se mantiene activa la señal DTR\footnote{La señal DTR (\textit{Data Terminal Ready}) indica al dispositivo que el PC está listo para establecer la comunicación. Esta señal se fuerza a estar activa para habilitar el canal de datos y/o prevenir que la placa de desarrollo no se reinicie.} para garantizar la estabilidad del enlace.

	\item \textbf{Buffers (I/O):} 8192 bytes para reducir la latencia en transferencias grandes.
	\item \textbf{Timeouts:} Configuración no bloqueante con un tiempo de espera máximo de 50 ms por lectura.
\end{itemize}


 Tal como se puede ver en la figura \ref{fig:comunicationsUML} las comunicaciones se implementan mediante tres clases: 
 
\subsubsection{Clase \texttt{SerialComunication}}
 
 Esta es la clase fundamental dentro del modelo de comunicaciones pues se encarga de abstraer la API de Windows (\texttt{Win32 API}) para manejar de manera sencilla los datos enviados por el canal serie. Para ello, a continuación se describen brevemente los elementos de esta clase:
 \begin{itemize}
 	\item \textbf{Inicialización y selección del puerto}: para iniciar la comunicación es necesario identificar primero el puerto asignado al dispositivo PSOC. Para ello, se utiliza el método \texttt{AvailablePorts}, que escanea el registro del sistema para listar los puertos COM activos. Una vez seleccionado el puerto objetivo, las funciones \texttt{openPort} y \texttt{closePort} gestionan la apertura del descriptor de archivo y la liberación de recursos, respectivamente.
 	
 	\item \textbf{Envío de mensajes}: para enviar mensajes el mecanismo es sencillo pues basta con usar la función \texttt{send} con el mensaje deseado y se enviará por el canal serie automáticamente.
 	\item \textbf{Recepción de mensajes}: para recibir mensajes y no tener que bloquear el flujo principal del programa, se ha implementado un patrón Productor-Consumidor mediante multihilo:
 	\begin{itemize}
 		\item \textbf{Hilo de Captura}: mediante la función \texttt{startReceiving}, se despliega un hilo secundario que ejecuta un bucle de lectura. Este hilo monitoriza constantemente el puerto serie y, al detectar bytes entrantes, los transfiere inmediatamente a un buffer intermedio (\texttt{receiveBuffer}) y así liberar espacio del buffer del puerto serie. Para evitar el consumo excesivo de CPU durante la espera, se incluye un breve retardo (\textit{sleep}) de 10 ms entre ciclos de lectura.
 		\item \textbf{Sincronización y acceso}: dado que el buffer de recepción es un recurso compartido, todas las operaciones de escritura (desde el hilo) y lectura (desde la aplicación) están protegidas por un \texttt{std::mutex} para evitar condiciones de carrera.
 		\item \textbf{Interfaz de Consumo}: para recuperar los datos enviados se utiliza el método
 		 \texttt{ getRece}\-\ \texttt{ivedMessage}, el cual extrae de forma segura los mensajes almacenados en el buffer circular, garantizando la integridad de los datos en un entorno concurrente.
 	\end{itemize}
 	
 \end{itemize}

\subsubsection{Clase \texttt{CircularBuffer}}
Esta clase implementa una estructura de datos de tipo \acrshort{fifo} sobre un espacio de memoria preasignado. Su función crítica es actuar como almacenamiento intermedio o buffer entre el hilo de recepción de la UART y la lógica de aplicación. Al utilizar un puntero de lectura y uno de escritura que rotan sobre el array, se consigue una inserción y extracción de datos eficiente sin la sobrecarga computacional que implicaría el redimensionamiento dinámico de vectores.

\subsubsection{Clase \texttt{SerialPacketTransport}}
Esta clase es esencial para el modelo criptográfico mediante agentes descrito en la figura \ref{fig:mainprotocol} y para garantizar que no se sature el microcontrolador pues los tamaños de claves pueden ser muy elevados entre 1312 y 14421 bytes como se describió en las tablas \ref{tab:KyberParams}, \ref{tab:SaberParams} y \ref{tab:HQCParams}. Para ello, se estructura la comunicación mediante un protocolo de enpaquetado ligero como una capa superior a la clase \texttt{SerialComunication}, permitiendo el envío de bloques de datos discretos. Esta clase tiene las siguientes características:


\begin{itemize}
	\item \textbf{Protocolo de encabezado}: para distinguir el inicio y fin de cada mensaje en el flujo continuo del puerto serie, la clase antepone a cada paquete una cabecera de 16 bits (2 bytes) en formato Little Endian. Esta cabecera indica la longitud exacta de la carga útil, permitiendo gestionar paquetes de hasta 65.535 bytes (64 KB).
	
	\item \textbf{Empaquetación en el envío}: el método \texttt{sendPacket} no envía el mensaje completo de golpe, si no que realiza una fragmentación en bloques de 4096 bytes. Esta estrategia se utiliza para evitar saturar los buffers internos del PSOC y mejorar la estabilidad de la transmisión.
	
	\item \textbf{Recepción con reensamblado y Timeout}: el método \texttt{receivePacket} implementa una lógica de lectura en dos fases: primero espera la recepción de los 2 bytes de cabecera para conocer el tamaño esperado y, posteriormente, acumula los fragmentos recibidos hasta completar el paquete. Para evitar bloquear el programa permanentemente se introduce un tiempo de espera o timeout, que aborta la operación si el paquete no se completa dentro del tiempo estipulado.
	\newline
	
	Cabe justificar que, si bien la capa inferior utiliza un modelo multihilo para la captura de datos, esta clase expone una interfaz bloqueante. Esta decisión se alinea con la naturaleza secuencial del protocolo de intercambio de claves, donde cada paso criptográfico depende estrictamente de la finalización del paso anterior y la recepción completa de la respuesta del otro agente, haciendo innecesaria una gestión asíncrona a nivel de aplicación.
\end{itemize}
\newline
\begin{figure}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tikzpicture}
			
			% ---------------------------------------------------------
			% 1. LEFT COLUMN: The "Big" Class
			% ---------------------------------------------------------
			\begin{class}[text width=9cm]{SerialComunication}{0, 0}
				\attribute{-availablePorts: vector$<$pair$<$int,wstring$>$$>$}
				\attribute{-hSerial: HANDLE}
				\attribute{-running: atomic$<$bool$>$}
				\attribute{-receiveThread: thread}
				\attribute{-receiveMutex: mutex}
				
				\operation{-setAvailablePorts()}
				\operation{-receiveLoop()}
				\operation{+SerialComunication(in bufferSize: int)}
				\operation{+updateAvailablePorts()}
				\operation{+openPort(in port:int)}
				\operation{+closePort()}
				\operation{+send(in message: str)}
				\operation{+isBufferEmpty()}
				\operation{+getReceivedMessage()}
				\operation{+startReceiving()}
				\operation{+stopReceiving()}
				\operation{+displayAvailablePorts()}
				\operation{+getAvailablePorts()}
			\end{class}
			
			% ---------------------------------------------------------
			% 2. RIGHT COLUMN: The Stacked Classes
			% ---------------------------------------------------------
			
			% --- TOP RIGHT: SerialPacketTransport ---
			% CHANGED Y=0 to Y=5 so it sits ABOVE the center line
			\begin{class}[text width=9cm]{SerialPacketTransport}{11, 0}
				\attribute{-internalBuffer: str}
				\operation{+SerialPacketTransport(inout s: SerialComunication)}
				\operation{+sendPacket(in data: vector$<$char$>$)}
				\operation{+receivePacket(out data: vector$<$char$>$, in ms: int)}
			\end{class}
			
			% --- BOTTOM RIGHT: CircularBuffer ---
			% Y=-5 is perfect for the bottom one
			\begin{class}[text width=5cm]{CircularBuffer}{11, -2.7}
				\attribute{-size: int}
				\attribute{-head: int}
				\attribute{-tail: int}
				\attribute{-count: int}
				\attribute{-buffer: str}
				
				\operation{+CircularBuffer(in size: int)}
				\operation{+push(in value: str)}
				\operation{+pop(out value: str)}
				\operation{+isempty()}
				\operation{+isfull()}
				\operation{+getCount()}
				\operation{+getSize()}
			\end{class}
			
			% ---------------------------------------------------------
			% 3. CONNECTIONS
			% ---------------------------------------------------------
			
			% DEFINE THE ARROW STYLE
			% {Diamond...}-  means "Put a diamond at the START, nothing at the END"
			% ARROW STYLE: Diamond at the START of the line
			\tikzset{comp/.style={{Diamond[fill=black, width=3mm, length=5mm]}-}}
			
			% RELATION 1: Transport (Right) -> Communication (Left)
			% Diamond on Transport.
			% Draw from Transport.west -> Horizontal intersection with Communication.east
			\draw[comp] (SerialPacketTransport.west) -- (SerialPacketTransport.west -| SerialComunication.east)
			node[midway, above] {serial};
			
			% RELATION 2: Communication (Left) -> Buffer (Right)
			% Diamond on Communication.
			% Draw from Horizontal intersection on Communication.east -> Buffer.west
			\draw[comp] (CircularBuffer.west -| SerialComunication.east) -- (CircularBuffer.west)
			node[midway, above, yshift=2mm] {receiveBuffer};
			
		\end{tikzpicture}%
	}
	\caption{Diagrama de clases en UML para implementar las comunicaciones por serial.}
	\label{fig:comunicationsUML}
	
\end{figure}

\subsection{Modelo criptográfico}
Para implementar el modelo de agentes de la figura \ref{fig:mainprotocol} se utiliza una interfaz común \texttt{keyexchange} para acceder a los distintos algoritmos de cifrado postcuántico y mediante la clase \texttt{KEMProtocol} se implementa el protocolo. Además, para ejecutar los tests de rendimiento o benchmarks para cada algoritmo se utiliza la clase auxiliar \texttt{AlgorithmTester}.



\subsubsection{Plantilla \texttt{SecureVector}}
En el desarrollo de software criptográfico robusto, normalmente se recomienda el uso de memoria estática (\texttt{stack}) para el almacenamiento de material sensible, como las claves privadas. Esto se debe a que la gestión de memoria dinámica (\texttt{heap}) introduce una superficie de ataque que puede ser explotada para extraer información residual o fragmentada.
\newline

No obstante, dada la naturaleza modular de este banco de pruebas y la necesidad de instanciar dinámicamente algoritmos con requisitos de memoria heterogéneos, el uso del \texttt{heap} resulta inevitable. Para mitigar los riesgos de seguridad asociados, se ha implementado la plantilla \texttt{SecureVector}.
\newline

La plantilla \texttt{SecureVector} actúa como un contenedor seguro basado en \texttt{std::vector}. La principal modificación reside en la sobrecarga de la rutina de desasignación: antes de liberar el bloque de memoria y devolverlo al sistema operativo, la clase sobrescribe explícitamente el contenido con ceros. Esta medida preventiva garantiza que no permanezcan trazas de información confidencial en la memoria no asignada.

\subsubsection{Clase \texttt{keyexchange}}
Dado que los métodos de los algoritmos de cifrado postcuántico son comunes, se ha creado una interfaz unificada que resuelve su instanciación mediante polimorfismo. De esta forma, las clases derivadas representan los algoritmos específicos, añadiendo una capa de abstracción sobre los envoltorios en C descritos en el listing \ref{lst:wrapper_core}.
\newpage

\subsubsection{Clase \texttt{KEMProtocol}}

Esta clase implementa el protocolo criptográfico descrito en la figura \ref{fig:mainprotocol} mediante una máquina de estados finitos. Dado que el flujo de ejecución es secuencial y dependiente del extremo de la comunicación, el constructor recibe dos parámetros fundamentales: el rol a desempeñar (Alice como \texttt{INITIATOR} o Bob como \texttt{RESPONDER}) y una referencia al algoritmo criptográfico deseado (Saber, Kyber o \acrshort{hqc}).
\newline

Para gestionar la variabilidad de algoritmos se aplica el patrón de diseño Estrategia. Esto permite abstraer las operaciones primitivas (generación de claves, encapsulado y decapsulado) tras una interfaz común, desacoplando la lógica de control de estado de la implementación matemática específica de cada algoritmo.
\newline


El comportamiento de la máquina de estados varía según el rol asignado: 
\begin{itemize} 
	\item \textbf{Rol INITIATOR (Alice)}: Comienza en el estado \texttt{INIT}. Al invocar el método \texttt{start} \texttt{\_negotiation}, la clase genera el par de claves, transiciona al estado \texttt{WAITING\_FOR\_CT} y devuelve la clave pública. Esta clave queda disponible y debe ser transmitida por el canal de comunicación (en este proyecto, enviada vía serie al PSoC). 
	\item \textbf{Rol RESPONDER (Bob)}: Inicia en el estado \texttt{INIT} y permanece a la espera. Su transición ocurre únicamente cuando se solicita procesar un mensaje externo mediante el método \texttt{process\_message}. 
\end{itemize}

Cuando la clase recibe un mensaje mediante el método \texttt{process\_message} y se encuentra en un estado válido de espera (es decir, en \texttt{INIT} si es Bob o en \texttt{WAITING\_FOR\_CT} si es Alice), ejecuta la lógica criptográfica correspondiente: encapsulación para el responder o decapsulación para el initiator. Tras finalizar la operación con éxito, la máquina transiciona al estado final \texttt{ESTABLISHED}, completando el intercambio.
\newline

Para proteger la información crítica, el secreto compartido y la clave privada se gestionan mediante la plantilla \texttt{SecureVector} mencionada anteriormente. De esta manera el sistema contempla un estado de \texttt{FAILURE} al que se transiciona si se solicita una operación inválida para el rol actual, etapa actual o si falla alguna operación del intercambio de claves.
\newline

Cabe destacar que para cumplir seguridad \acrshort{cca2} las funciones del intercambio de claves no pueden fallar debido a que ello implicaría que el atacante puede obtener información del oráculo. Si bien en algunas implementaciones se contempla la posibilidad de fallo si la función \texttt{randombytes} se queda sin entropía al consultar el \acrshort{trng}, en el alcance de este trabajo no se contempla dicha posibilidad, asumiendo disponibilidad de entropía infinita. 
\subsubsection{Clase \texttt{AlgorithmTester}}
Esta clase actúa como un entorno de ejecución controlado para realizar benchmarks de los algoritmos de cifrado. Aprovechando el patrón Estrategia, la clase \texttt{AlgorithmTester} interactúa con los algoritmos a través de su interfaz común, lo que permite someter a cualquiera de los esquemas implementados (Kyber, Saber, \acrshort{hqc}) a las mismas baterías de pruebas bajo condiciones idénticas. La descripción detallada de la metodología de pruebas y sus resultados se encuentra en la sección \ref{sec:testes}.


\begin{landscape}
\begin{figure}[H]
	\centering
	% This resizes the diagram to fit perfectly on the page width
	\resizebox{0.95\paperwidth}{!}{%
		\begin{tikzpicture}
			
			% ---------------------------------------------------------
			% 1. DEFINE CLASSES
			% ---------------------------------------------------------
			
			% --- Interface: KeyExchange (CENTER) ---
			\begin{interface}[text width=9cm]{keyexchange}{0,0}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(inout pk: char, inout sk: char)}
				\operation{+encapsulate(inout ct: char,inout ss:char, inout pk:char)}
				\operation{+decapsulate(inout ss: char,inout ct:char, inout sk:char)}
			\end{interface}
			
			% --- Class: AlgorithmTester (LEFT) ---
			% Positioned to the left of the interface
			\begin{class}[text width=8.0cm]{AlgorithmTester}{-11, 1.2}
				\attribute{-frequency\_: long}
				\attribute{-stack\_trap: uint8\_t}
				\attribute{-STACK\_SIZE: const int}
				\attribute{-CANARY: const int}
				\attribute{-pk\_buf: vector$<$char$>$}
				\attribute{-sk\_buf: vector$<$char$>$}
				\attribute{-ct\_buf: vector$<$char$>$}
				\attribute{-ss\_buf: vector$<$char$>$}
				
				\operation{+AlgorithmTester(inout alg: KeyExchange)}
				\operation{+runStackAnalysis()}
				\operation{+runCycleAnalysis()}
				\operation{+runThroughputAnalysis()}
				\operation{+paintStack()}
				\operation{+checkStackDepth()}
				\operation{+resizeBuffers()}
			\end{class}
			
			% --- Class: KEMProtocol (RIGHT) ---
			% Positioned to the right of the interface
			\begin{class}[text width=10cm]{KEMProtocol}{13, 0.1}
				\attribute{-secret\_key\_: SecureVector}
				\attribute{-shared\_secret\_: SecureVector}
				
				\operation{+KEMProtocol(inout kem: KeyExchange, in role: ProtocolRole)}
				\operation{+getState()}
				\operation{+start\_negotiation()}
				\operation{+process\_message(in input\_msg: char)}
				\operation{+get\_shared\_secret()}
				\operation{-handle\_encapsulation(in pk: vector)}
				\operation{-handle\_decapsulation(in ct: vector)}
				\operation{-transition\_to\_error(out msg: char)}
			\end{class}
			
			% --- Datatype: SecureVector (ABOVE KEMProtocol) ---
			\begin{class}[text width=6.5cm]{SecureVector}{13, 4}
				\stereotype{datatype}
				\operation{+allocate(in n: size\_t)}
				\operation{+deallocate(inout p: classT, in n: size\_t)}
			\end{class}
			
			% --- Implementations (BOTTOM CENTER) ---
			% Fully restored methods for all three classes
			
			\begin{class}[text width=4.2cm]{Saber}{0, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			\begin{class}[text width=4.2cm]{Kyber}{-5, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			\begin{class}[text width=4.2cm]{HQC}{5, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			% --- Enums (BOTTOM RIGHT) ---
			% Moved down to Y=-11 to avoid overlap
			\begin{class}[text width=3cm]{ProtocolRole}{11, -11}
				\stereotype{enumeration}
				\attribute{+INITIATOR}
				\attribute{+RESPONDER}
			\end{class}
			
			\begin{class}[text width=4cm]{ProtocolState}{15, -11}
				\stereotype{enumeration}
				\attribute{+INIT}
				\attribute{+WAITING\_FOR\_CT}
				\attribute{+ESTABLISHED}
				\attribute{+FAILURE}
			\end{class}
			
			% ---------------------------------------------------------
			% 2. DRAW RELATIONS
			% ---------------------------------------------------------
			
			% Style for the Composition Diamond (filled black diamond)
			% "start" means the diamond is at the beginning of the line
			\tikzset{diamond_start/.style={{Diamond[fill=black, width=3mm, length=5mm]}-}}
			
			% A. AlgorithmTester <>-> KeyExchange
			% Diamond is attached to AlgorithmTester
			\draw[diamond_start] (AlgorithmTester.east) -- (keyexchange.west) 
			node[midway, above, yshift=0.5mm] {algo\_};
			
			% B. KEMProtocol <>-> KeyExchange
			% Diamond is attached to KEMProtocol
			\draw[diamond_start] (KEMProtocol.west) -- (keyexchange.east) 
			node[midway, above] {kem\_: unique\_ptr};
			
			% C. KEMProtocol <>-> ProtocolRole
			% Vertical line down, then horizontal. Diamond at KEMProtocol.
			% pos=0.1 places the text near the top (near the diamond)
			% anchor=east forces the text to sit to the LEFT of the line
			\draw[diamond_start] (KEMProtocol.south) -- ++(0,-1.5) -| (ProtocolRole.north) 
			node[pos=0.1, anchor=east, yshift=2mm] {role\_}; 
			
			% D. KEMProtocol <>-> ProtocolState
			% Vertical line down, then horizontal. Diamond at KEMProtocol.
			% pos=0.1 places the text near the top (near the diamond)
			% anchor=west forces the text to sit to the RIGHT of the line
			\draw[diamond_start] (KEMProtocol.south) -- ++(0,-1.5) -| (ProtocolState.north) 
			node[pos=0.1, anchor=west, yshift=2mm] {state\_};
			
			% E. SecureVector Association
			% Simple line, matching the diagram's placement

			
		\end{tikzpicture}%
	}
	\caption{Diagrama de clases en UML para implementar la lógica criptográfica.}
	\label{fig:logicUML}
	
\end{figure}
\end{landscape}
\section{Implementación de algoritmos en el microcontrolador}
La integración de algoritmos postcuánticos en sistemas embebidos presenta desafíos significativos debido a la limitación de recursos. No obstante, la migración del código fuente resulta directa gracias a las implementaciones portables. La única adaptación necesaria a nivel de plataforma es la implementación de la función \texttt{randombytes}, para la generación de los \acrshort{trng} mediante el hardware. 
\newline


Sin embargo, el desafío principal residió en la selección y configuración del entorno de desarrollo (IDE). Inicialmente se evaluó el uso de \textit{PSoC Creator}, la herramienta tradicional para esta familia de microcontroladores. Durante las pruebas con el algoritmo \acrshort{hqc}, que demanda una cantidad elevada de memoria (aprox. 170 KB), la ejecución fallaba sistemáticamente derivando en excepciones de hardware.
\newline


El análisis en tiempo de depuración reveló un comportamiento anómalo en la gestión de memoria: el puntero de pila (Stack Pointer) o los accesos a memoria apuntaban a direcciones en el rango \texttt{0x78...}, una región inválida situada aproximadamente a 1.8 GB de distancia del espacio direccionable real de la SRAM, cuya base se encuentra en \texttt{0x08...} según el manual de arquitectura \cite{infineon_psoc6_arch_trm}. Adicionalmente, PSoC Creator impone restricciones en la arquitectura de seguridad, limitando el acceso directo a los registros del \acrshort{trng} desde el núcleo principal (Cortex-M4), forzando una arquitectura maestro-esclavo con el núcleo Cortex-M0+ que añade complejidad innecesaria para este proyecto.
\newline

Debido a estas limitaciones críticas, se optó por migrar el desarrollo al entorno \textit{ModusToolbox}. Esta plataforma moderna permite el uso directo de la \textit{Peripheral Driver Library} (PDL) para controlar el \acrshort{trng} desde el núcleo M4 y gestiona el mapa de memoria de forma más eficiente, permitiendo la correcta ejecución de \acrshort{hqc}. Aunque no se ha aislado la causa raíz del fallo en el entorno anterior, el éxito en ModusToolbox se atribuye a una combinación de factores en la gestión del \textit{Linker Script}:
\begin{itemize} 
	\item \textbf{Gestión dinámica de memoria (Heap vs Stack):} Para soportar tamaños de clave variables, las claves y textos cifrados se reservan dinámicamente en el heap. Se hipotetiza que el script de enlazado de PSoC Creator define regiones rígidas o contiguas que provocan una colisión temprana entre el stack (creciendo hacia abajo) y el heap (creciendo hacia arriba) cuando se demandan grandes bloques contiguos para \acrshort{hqc}. 
	\item \textbf{Optimizaciones del Compilador GCC:} ModusToolbox integra versiones más recientes del toolchain GCC ARM. Es probable que las diferencias en las optimizaciones de gestión de pila y la definición de las secciones de memoria en el script de arranque eviten el desbordamiento o la corrupción de punteros que se observaba anteriormente. 
\end{itemize}


\section{Diagrama de secuencia}
En la figura \ref{fig:umltiempo} se detalla el diagrama de secuencia diseñado para validar el funcionamiento del protocolo de establecimiento de claves. La interacción sigue una arquitectura estricta de Maestro-Esclavo, donde el servidor (ordenador de propósito general) orquesta la comunicación y el PSOC actúa como periférico. Esta decisión de diseño permite desacoplar la lógica de control del dispositivo embebido, centralizando la gestión de estados y el acceso al canal serie en el servidor, lo cual facilita la escalabilidad en un hipotético entorno industrial con múltiples nodos.
\newline

El flujo de ejecución consta de tres fases diferenciadas:

\begin{enumerate}
	\item  \textbf{Inicialización y Verificación (Echo Test)}: tras la apertura del puerto COM y una espera inicial de 2 segundos para garantizar el arranque del PSOC, se ejecuta una prueba de eco (Echo Test). Esta fase es crítica para validar la integridad física del canal y la sincronización de la configuración UART. Si esta validación falla o no se recibe respuesta en la ventana de tiempo estipulada, el servidor aborta la operación inmediatamente cerrando el puerto.
	
	\item  \textbf{Negociación de Roles}: superado el test inicial, el servidor determina arbitrariamente qué rol desempeñará (Alice o Bob) y comunica al PSOC el rol complementario. Como se observa en la figura, esto bifurca la ejecución en dos escenarios simétricos. Es relevante notar la diferencia en la gestión del tiempo:
	\begin{itemize}
		\item \textbf{En el PSOC:} se utilizan esperas bloqueantes para la recepción de datos, aprovechando que el dispositivo dedica sus recursos exclusivamente a esta tarea.
		\item \textbf{En el Servidor:} se implementan timeouts conservadores (20s y 25s) para la recepción de la clave pública y el texto cifrado respectivamente. Estos márgenes amplios son necesarios no solo para cubrir el tiempo de cómputo criptográfico del microcontrolador, si no también para compensar la latencia introducida por el buffer del puerto serie y la planificación de procesos del sistema operativo del PC.
	\end{itemize}
	
	\item  \textbf{Verificación del Secreto y Limitaciones}: finalmente, para confirmar el éxito del protocolo, ambos extremos intercambian el secreto compartido obtenido. Cabe destacar dos consideraciones técnicas sobre esta etapa:
	
	\begin{enumerate}
		\item \textbf{Gestión del Buffer:} se identificó un cuello de botella en la transmisión Servidor $\rightarrow$ PSoC. Para evitar el desbordamiento del buffer de recepción del microcontrolador y la consecuente pérdida de datos, se fragmenta el envío en paquetes pequeños, lo que justifica parte de la latencia observada.
		\item \textbf{Seguridad de la Validación:} el envío del secreto compartido en texto claro por el canal serie se realiza estrictamente con fines de depuración y validación académica. Tal como se discutió en la introducción (ver sección \ref{sec:intro}), en un entorno de producción esto constituiría una vulnerabilidad crítica. La verificación de integridad debería realizarse mediante un \acrfull{hmac}, sin revelar jamás el secreto original.
	\end{enumerate}
\end{enumerate}


\begin{figure}[H]
	% This box tells LaTeX: "Pretend this content fits in \linewidth and center it [c]"

	\includegraphics[width=0.9\linewidth]{figuras/umlTiempo}%
	
	\caption{Diagrama de secuencia en UML que representa un ejemplo de intercambio de claves entre un Servidor y un PSOC.}
	\label{fig:umltiempo}
\end{figure}
\newpage


\section{Tests de rendimiento realizados}
\label{sec:testes}
La validación experimental se basa en la metodología propuesta en \cite{teste4}, priorizando el análisis de ciclos de CPU para aislar la eficiencia algorítmica de la velocidad de reloj del hardware. No obstante, para caracterizar el comportamiento del sistema en un entorno de producción, se complementa esta métrica teórica con medidas de rendimiento práctico (throughput), es decir, número de ejecuciones por segundo, y un análisis exhaustivo del consumo de memoria de la pila (stack), factor limitante principal en sistemas embebidos.
\newline

Adicionalmente, el estudio evalúa la sobrecarga introducida por la transmisión de datos (coste de comunicación) y valida la robustez criptográfica del sistema mediante el análisis estadístico de los generadores de números aleatorios, asegurando así la integridad de las claves generadas.

\subsection{Dispositivos ensayados}
En este trabajo se ha ensayado la placa de desarrollo PSOC cyproto-063-ble y dos ordenadores con las características de la  tabla \ref{tab:specs}:

\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho si es necesario
		\begin{tabular}{@{}l l l l @{}}
			\toprule
			\textbf{Sistema} & \textbf{Procesador} & \textbf{Frecuencia} & \textbf{Memoria RAM} \\ \midrule
			\textbf{Portátil} & Intel Core i7-8750H & 2.20 GHz (Base) & 16 GB \\
			& (6 Núcleos / 12 Hilos) & 4.10 GHz (Máx.) & (2667 MHz) \\ \midrule
			\textbf{Torre} & AMD Ryzen 7 5800X & 3.80 GHz (Base) & 32 GB \\
			& (8 Núcleos / 16 Hilos) & 4.70 GHz (Máx.) & (3600 MHz) \\ \midrule
			\textbf{PSOC 6 BLE} & CY8C6347BZI-BLD53 & 100 MHz (Configurada) & 288 KB \\
			(CY8CPROTO-063) & (Dual Core M4/M0+) & 150 MHz (Máx. Capaz) & (SRAM) \\ \midrule
		\end{tabular}
	}
	\caption{Comparativa de especificaciones de los sistemas evaluados}
	\label{tab:specs}
\end{table}

\subsection{Ciclos de CPU}
Para evaluar el coste computacional de las primitivas criptográficas (generación de claves, encapsulado y desencapsulado) cada test se ejecuta en múltiples iteraciones. El objetivo es mitigar el ruido introducido por interrupciones del sistema, cambios de contexto o procesos en segundo plano, permitiendo así obtener una media aritmética estable y descartar valores atípicos.
\newline

Para ello, en función del sistema se usa una estrategia distinta:
\begin{itemize}
	\item \textbf{Entorno Windows (Arquitectura x86\_64):} 
	Se utilizan las instrucciones intrínsecas proporcionadas por el compilador MSVC. Específicamente, se emplea \texttt{\_\_rdtsc} (Read Time-Stamp Counter), que lee el contador de ciclos de reloj del procesador, junto con \texttt{\_mm\_lfence} (Load Fence). 
	\newline
	
	La instrucción \texttt{\_mm\_lfence} es crítica en procesadores modernos con ejecución fuera de orden, ya que actúa como una barrera de serialización. Esto garantiza que todas las instrucciones previas a la medición hayan terminado y que ninguna instrucción posterior comience antes de leer el contador, asegurando que la medición capture estrictamente el código objetivo.
	\newline
	
	Para ver el funcionamiento del código ver el Listing \ref{lst:WIN}.

	\begin{lstlisting}[language=C, caption={Instrumentación para medición de ciclos en Windows (x86\_64)}, label={lst:WIN}]
		unsigned long long start, end;
		
		// Serializacion previa para evitar ejecucion especulativa
		_mm_lfence();
		start = __rdtsc(); // Lectura del contador inicial
		_mm_lfence();
		
		funcion_criptografica(); // Codigo bajo prueba
		
		_mm_lfence();
		end = __rdtsc();   // Lectura del contador final
		_mm_lfence();
		
		// El resultado (end - start) son los ciclos consumidos
	\end{lstlisting}
	
	\item \textbf{Entorno Embebido (PSoC 6 - ARM Cortex-M4):} 
	En la arquitectura ARM, se accede directamente a la unidad de depuración DWT (Data Watchpoint and Trace). A diferencia de los contadores estándar (como SysTick), el registro \texttt{DWT->CYCCNT} ofrece una resolución de un ciclo de reloj y es accesible con baja latencia.
	\newline
	
	Para su uso, es necesario habilitar previamente el bloque de trazas a través del registro \texttt{DEMCR} y reiniciar el contador, tal como se detalla en el Listing \ref{lst:initCicles}.
	
	\begin{lstlisting}[language=C, caption={Configuración y lectura del contador DWT en ARM Cortex-M para medición de número de ciclos.}, label={lst:initCicles}]
		// Inicializacion del contador de ciclos (DWT)
		void CycleCounter_Init(void)
		{
			// 1. Habilitar bloques de traza y depuracion (TRCENA)
			CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
			
			// 2. Resetear el contador a 0
			DWT->CYCCNT = 0;
			
			// 3. Habilitar el conteo de ciclos (CYCCNTENA)
			DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
		}
		
		// Lectura en linea
		// Nota: DWT->CYCCNT es un registro de 32 bits.
		// Se debe tener en cuenta el desbordamiento en operaciones muy largas.
		
		CycleCounter_Init();
		uint32_t start_cycles = DWT->CYCCNT;
		
		funcion_criptografica();
		
		uint32_t end_cycles = DWT->CYCCNT;
		uint32_t total_ciclos = end_cycles - start_cycles;
	\end{lstlisting}
\end{itemize}


\subsection{Caudal de Procesamiento}
Esta prueba constituye una métrica de caudal (throughput) complementaria al conteo de ciclos. La metodología consiste en ejecutar la primitiva criptográfica dentro de un bucle continuo, contabilizando el número de iteraciones completas realizadas hasta que el tiempo transcurrido supera el umbral de un segundo. Es importante destacar que el bucle siempre espera a que finalice la operación en curso antes de detenerse.
\newline

Aunque esta métrica está directamente correlacionada con la prueba anterior (a menos ciclos, más operaciones por segundo), se incluye para ofrecer una visión tangible del tiempo real de ejecución, facilitando la estimación de la carga de trabajo efectiva que puede soportar el dispositivo.
\newpage

\subsection{Uso de Pila}
La medición del uso máximo de pila es crítica en sistemas embebidos para evitar desbordamientos que deriven en excepciones de hardware. Para cuantificar este consumo, se emplea la técnica conocida como Stack Painting.
\newline

El procedimiento consiste en llenar una región reservada de la memoria de pila (en este caso, un array de 256 kB) con un patrón de bytes conocido y poco probable, denominado \esquote{canario} (se utiliza el valor \texttt{0xAA}). Posteriormente, se ejecuta la función criptográfica objetivo. Dado que las operaciones de la función sobrescribirán la pila con sus propias variables locales y direcciones de retorno, el patrón original quedaría alterado. Por tanto, una vez finalizada la ejecución, se recorre la memoria reservada para identificar la \esquote{marca de agua} más profunda, es decir, la dirección de memoria más lejana donde el patrón ha sido modificado. La diferencia entre el inicio del buffer y esta marca determina el consumo máximo de pila en bytes (ver Listado \ref{lst:stacksz}).
\newline

Si durante las pruebas el consumo excediera el tamaño del buffer reservado, se produciría un fallo de sistema. No obstante, durante la evaluación de las primitivas criptográficas seleccionadas, el tamaño de 256 kB resultó suficiente para contener la ejecución de todos los algoritmos sin incidencias.


\begin{lstlisting}[language=C, caption={Implementación de la técnica de Stack Painting}, label={lst:stacksz}]
	// Constantes utilizadas en el proyecto
	static const int STACK_SIZE = 256 * 1024;
	static const int CANARY = 0xAA;
	
	// Inicializa la pila con el patrón conocido (Canario)
	void paintStack() {
		volatile uint8_t buffer[STACK_SIZE];
		stack_trap_ = &buffer[0];
		for (int i = 0; i < STACK_SIZE; i++) {
			buffer[i] = CANARY;
		}
	}
	
	// Verifica la profundidad de escritura tras la ejecución
	size_t AlgorithmTester::checkStackDepth() {
		size_t depth = 0;
		for (int i = 0; i < STACK_SIZE; i++) {
			if (stack_trap_[i] != CANARY) {
				depth = STACK_SIZE - i;
				break;
			}
		}
		return depth;
	}	
	
	// Ejemplo de ejecución de un test
	paintStack();
	funcion_criptografica();
	size_t depth = checkStackDepth();
\end{lstlisting}

\subsection{Evaluación de tiempos}
Como última etapa de validación, se evalúa el coste temporal de los protocolos criptográficos. Dado que las mediciones se realizan desde el servidor (PC con procesador AMD), el tiempo total observado incluye inevitablemente la latencia introducida por el canal de comunicaciones serie.
\newline

Para aislar el tiempo efectivo de cómputo del microcontrolador (tiempo de procesamiento) respecto al tiempo de transferencia, se emplea una metodología diferencial basada en dos mediciones:
\begin{enumerate} 
	\item \textbf{Caracterización del Canal}: se utiliza la operación de \texttt{EchoTest} (descrita en la figura \ref{fig:umltiempo}) para medir el tiempo de ida y vuelta de los datos sin carga de procesamiento criptográfico. Esto permite establecer una línea base de la velocidad del enlace y calcular métricas como la latencia media por Byte y la velocidad de transferencia efectiva. 
	\item \textbf{Estimación del Cómputo}: al medir el tiempo total de ejecución de los algoritmos, se resta el tiempo de comunicación estimado previamente. De esta forma, se obtiene un valor fiable del tiempo que el PSOC dedica exclusivamente a la ejecución del algoritmo.
\end{enumerate}



\subsection{Evaluación de la Fuente de Aleatoriedad (randombytes)}
Con el objetivo de verificar la idoneidad criptográfica de los generadores de números aleatorios implementados tanto en el PSOC como en el entorno Windows, se ha diseñado un protocolo de validación híbrido que combina el análisis cualitativo (ensayos visuales) con el análisis cuantitativo riguroso (baterías de tests estadísticos).
\newline

Para la ejecución de las pruebas, se generaron ficheros de datos de gran tamaño mediante llamadas iterativas a \texttt{randombytes}. Se optó por un volumen de 100 MB para los análisis visuales y se amplió la muestra a 1 GB para los ensayos cuantitativos.

\subsubsection{Ensayos Visuales}
Estas pruebas permiten una detección rápida de fallos estructurales graves de manera visual. Se han empleado tres técnicas de representación:
\begin{itemize}
	\item \textbf{Histograma de Frecuencias:} Permite verificar la bondad de ajuste de los datos a una distribución uniforme ideal. Se espera observar una distribución plana donde todos los valores del byte ($0-255$) aparezcan con la misma frecuencia.
	\item \textbf{Bitmap (Mapa de Bits):} Consiste en visualizar los bits generados como píxeles de una imagen en escala de grises. Una fuente de alta entropía debe producir una imagen de ruido blanco sin patrones geométricos, líneas o estructuras repetitivas visibles.
	\item \textbf{Lag Plot (Gráfico de Retardo):} Diagrama de dispersión que representa la relación entre un dato $x_i$ y su consecutivo $x_{i+1}$. Esta técnica es eficaz para revelar correlaciones seriales o dependencias a corto plazo entre los bytes generados.
\end{itemize}

\subsubsection{Baterías de Tests Estadísticos}
Para una validación profunda, se somete la secuencia a las suites estándar de la industria y la literatura académica. Las herramientas seleccionadas se describen a continuación:

\begin{itemize}
	\item \textbf{ENT \cite{ENTLimita}}: batería básica y extremadamente rápida que evalúa propiedades fundamentales de la secuencia, como la entropía, la media aritmética y la correlación serie. Su principal utilidad radica en un primer análisis preliminar, aunque presenta limitaciones conocidas, como la falta de cálculo de p-valores rigurosos para la mayoría de sus pruebas.
	
	\item \textbf{Dieharder \cite{brown2006dieharder}}: suite de código abierto que extiende y mejora la clásica batería \esquote{Diehard} A diferencia de su predecesora, permite parametrizar los tests y aplica pruebas de Kolmogorov-Smirnov a la distribución de múltiples p-valores obtenidos, aumentando la capacidad de discernir los resultados. Integra diferentes pruebas, incluyendo versiones de los tests del \acrshort{nist} y de Knuth, posicionándose como una herramienta versátil para pruebas de números aleatorios.
	\item \textbf{TestU01 \cite{U01test}}: biblioteca exhaustiva implementada en C que ofrece una vasta colección de utilidades para pruebas empíricas de generadores de números aleatorios uniformes. Es ampliamente reconocida por sus baterías predefinidas de intensidad creciente las cuales someten a los generadores a pruebas de estrés muy rigurosas, capaces de detectar defectos sutiles que otras suites pasan por alto.
	\item \textbf{NIST SP 800-22 \cite{rngNistPaper}}: paquete estadístico diseñado específicamente por el \acrshort{nist} para evaluar generadores de números aleatorios en aplicaciones criptográficas. Consta de 15 pruebas estadísticas que analizan propiedades críticas como la frecuencia, la complejidad lineal, las excursiones aleatorias y la entropía aproximada.
\end{itemize}

