\chapter{Desarrollo}
En este capítulo se describe el código y la implementación propia realizada en base a los algoritmos proporcionados por el \acrshort{nist}.
\section{Adaptación de Primitivas Criptográficas} La primera fase del desarrollo se centró en la extracción y depuración de los núcleos algorítmicos en lenguaje C, con el objetivo de garantizar su portabilidad independientemente de la plataforma escogida.
\newline

Las implementaciones de referencia presentan dependencias de compilación ligadas a entornos UNIX, presencia de trazas de depuración (\textit{debug prints}) dispersas en múltiples ficheros y cierto acoplamiento entre la lógica criptográfica y los vectores de prueba.  Por ello, en esta sección se detallan las refactorizaciones realizadas y se describe la estructura final de los ficheros fuente para cada algoritmo.

\subsection{Kyber y Saber: Implementaciones de Referencia}
Para los algoritmos Kyber y Saber se han integrado las implementaciones de referencia presentadas por los autores en las rondas 3 y 4 del \acrshort{nist} \cite{nistPQCround3} \cite{nistPQCround4}. 
\newline

Se han aplicado modificaciones estructurales menores, siendo la más relevante el desacoplamiento del módulo de generación de aleatoriedad. En la versión original, el código dependía de \texttt{rng.h} para generar secuencias deterministas a partir de una semilla fija. Esta dependencia se ha sustituido por la interfaz genérica \texttt{randombytes.h}, la cual permite inyectar una fuente de entropía real del sistema. Para más detalles sobre esta gestión de aleatoriedad, consultar la sección \ref{rng:win}.

\newpage
\subsubsection{Estructura del código en Kyber}
En la tabla \ref{tab:kyber_files} se describe brevemente la estructura lógica del código de Kyber tras la limpieza del código \cite{kyber-spec-2021}.



\begin{table}[H]
	\centering
	
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{kem, indcpa} & Implementan el protocolo de intercambio de claves. En \texttt{indcpa} se encuentran los esquemas básicos de la \acrshort{mlwe} para obtener seguridad \acrshort{cpa} mientras que en el fichero \texttt{kem} mediante la \acrshort{tfo} se implementa la seguridad \acrshort{cca22}. \\
			
			& \texttt{api}& Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{kyber\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de Kyber.  \\ 
			& \texttt{verify} & Función para comparar dos vectores en tiempo constante. \\ \addlinespace
			\textbf{Matemáticas} & \texttt{poly, polyvec} & Definen las estructuras de datos para operaciones algebraicas sobre el anillo $R_q$. \\
			& \texttt{ntt, reduce} & Implementan la multiplicación rápida de polinomios mediante la \acrshort{ntt} y la reducción modular eficiente (se usa un módulo no potencia de 2 \(q=3329\)). \\
			& \texttt{cbd} & Generación de ruido determinista necesario para la seguridad LWE mediante la distribución binomial. \\ \addlinespace
			
			\textbf{Hashing}     & \texttt{fips202, sha, symetric} & Implementación del estándar SHA-3 (Keccak) junto a las interfaces necesarias para kyber. \\
			 \addlinespace
			
			\textbf{Sistema}     
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			&\texttt{params}&Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de Kyber.}
	\label{tab:kyber_files}
\end{table}
\newpage
\subsubsection{Estructura del código en Saber}
En la tabla \ref{tab:saber_files} se describe brevemente la estructura lógica del código de Saber tras la limpieza del código \cite{saber-spec-2020}.
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{kem, SABER\_indcpa} & Implementan el mecanismo de encapsulamiento. En \texttt{SABER\_indcpa} se define la lógica base del problema \acrshort{mlwr}  para seguridad \acrshort{cpa}, mientras que \texttt{kem} aplica la \acrshort{tfo} para alcanzar seguridad \acrshort{cca22}. \\
			& \texttt{api} &  Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{saber\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de Saber.  \\ 
			& \texttt{verify} & Función auxiliar para comparación de vectores en tiempo constante. \\ \addlinespace
			
			\textbf{Matemáticas} & \texttt{poly, pack\_unpack} & Estructuras de datos para el anillo $R_q$ y rutinas de optimización del ancho de banda. \\
			& \texttt{poly\_mul} & Implementa la multiplicación polinomial mediante Toom-Cook y Karatsuba. \\
			& \texttt{cbd} & Generación de ruido determinista mediante la Distribución Binomial Centrada. \\ \addlinespace
			
			\textbf{Hashing} & \texttt{fips202} & Implementación del estándar SHA-3 (Keccak). \\ \addlinespace
			
			\textbf{Sistema} 
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			& \texttt{SABER\_params} & Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de Saber.}
	\label{tab:saber_files}
\end{table}
\subsection{HQC: Selección de PQClean}
Para \acrshort{hqc}, se descartó la implementación de la ronda 4 del NIST en favor de la versión mantenida por el proyecto PQClean \cite{pqclean_github} \cite{SSR:KSSW22}. Esta decisión se fundamenta en la arquitectura de la versión original, la cual presenta un fuerte acoplamiento con el generador pseudoaleatorio determinista diseñado para pruebas  \acrlong{kat}(\acrshort{kat}). La versión de PQClean ofrece una interfaz para modificar la fuente de aleatoriedad de manera sencilla. Esto facilita el uso de una semilla fija para validación o una fuente de aleatoriedad real (\acrshort{trng}).
\newline

Es importante señalar que la implementación actual no garantiza seguridad \acrshort{cca2}. Esto se debe a que, durante la fase de desencapsulado, el mecanismo de verificación carece de rechazo implícito. Si el texto cifrado recalculado no coincide con el recibido, la función retorna un fallo explícito en lugar de generar un valor pseudoaleatorio indistinguible para un atacante. Esta limitación ha sido asumida dentro del alcance del proyecto priorizando la claridad conceptual, ya que, aunque su inclusión afectaría marginalmente a las métricas de rendimiento, no compromete la validación funcional de los algoritmos. Si se quisiera implementar la solución para un entorno de producción sería necesario utilizar la \acrshort{tfo}.

\newpage

\subsubsection{Estructura del código en \acrshort{hqc}}
En la tabla \ref{tab:hqc_files} se describe brevemente la estructura lógica del código de \acrshort{hqc} tras la limpieza del código \cite{pqclean_github}.
\begin{table}[H]
	\centering
	\resizebox{\textwidth}{!}{% Ajusta la tabla al ancho de página
		\begin{tabular}{@{}llp{7.5cm}@{}}
			\toprule
			\textbf{Categoría} & \textbf{Ficheros (.c/.h)} & \textbf{Descripción Funcional} \\ \midrule
			
			\textbf{Núcleo del esquema} & \texttt{code, hqc} & En \texttt{code} se define una interfaz a los mecanismos de corrección de errores, mientras que \texttt{hqc} implementa todo el mecanismo de intercambio de claves. \\
			& \texttt{api} & Archivo de api original del \acrshort{nist}. Tiene la problemática de ser poco flexible y dar problemas de enlazado si se usan varios cifrados distintos.\\
			& \texttt{hqc\_wrapper} & Envoltorio desarrollado para abstraer las funcionalidades de HQC.  \\ 
			& \texttt{parsing} & Funciones auxiliares para dar formato a las claves y los textos cifrados. \\ \addlinespace
			
			\textbf{Matemáticas} & \texttt{reed\_solomon, reed\_muller} & Implementan la codificación y decodificación de códigos correctores de errores. \\
			& \texttt{gf, gf2x, fft} & Implementa la aritmética en cuerpos de Galois y multiplicación de polinomios eficiente mediante la Transformada Rápida de Fourier. \\
			& \texttt{vector} & Implementa la aritmética entre vectores de bits. \\ \addlinespace
			
			\textbf{Hashing} & \texttt{fips202, shake\_ds, shake\_prng} & Implementación del estándar SHA-3 (Keccak) junto a las interfaces necesarias para \acrshort{hqc}. \\  \addlinespace
			
			\textbf{Sistema} 
			& \texttt{randombytes} &Función para generar la aleatoriedad en el esquema.\\
			& \texttt{parameters, domains} & Tabla de parametros del esquema de seguridad a utilizar.\\
			\bottomrule
		\end{tabular}%
	}
	\caption{Desglose funcional de los ficheros fuente de \acrshort{hqc}.}
	\label{tab:hqc_files}
\end{table}
\section{Unificación de Interfaces (Capa Wrapper)}
Se ha desarrollado un módulo envoltorio (\textit{wrapper}) para cada algoritmo con el objetivo de encapsular las implementaciones de referencia del \acrshort{nist} \cite{nistPQCround3} \cite{nistPQCround4} bajo una interfaz común. La estructura general de los ficheros de cabecera, denominados \texttt{AlgorithmWrapper.h}, se detalla en el Listing \ref{lst:wrapper_core}.
\newline

El propósito principal de esta capa de abstracción es homogeneizar las distintas implementaciones provistas por el \acrshort{nist}. Esto permite instanciar los algoritmos mediante un inicializador común ajustado al nivel de seguridad deseado (dependiente de la compilación de la librería con los parámetros correspondientes). Asimismo, este diseño resuelve los conflictos de enlazado (\textit{linking}) derivados del uso de símbolos idénticos en las APIs originales, facilitando así la intercambiabilidad dinámica entre los distintos algoritmos criptográficos.
\newline

Finalmente, en lo relativo a la gestión de memoria, se ha adoptado una filosofía donde la responsabilidad recae íntegramente en el usuario, quien debe encargarse de la asignación y liberación de los \textit{buffers}.
\newpage

\begin{lstlisting}[language=C, caption={Estructura genérica del wrapper para los algoritmos PQC}, label={lst:wrapper_core}]
	// Estructura comun para Kyber, HQC y Saber
	// Se sustituye "ALG" por el nombre del algoritmo especifico
	
	#include "alg_wrapper.h"
	#include "api.h" 
	
	// Nivel de seguridad actual (Estado interno)
	static alg_security_level_t current_security_level;
	static int is_initialized = 0;
	
	// Inicializacion del esquema
	int alg_init(alg_security_level_t security_level) {
		// Validacion del nivel de seguridad
		if (security_level != ALG_SEC_LEVEL_1 && 
		security_level != ALG_SEC_LEVEL_3 && 
		security_level != ALG_SEC_LEVEL_5) {
			return -1;
		}
		
		current_security_level = security_level;
		is_initialized = 1;
		return 0;
	}
	
	// Getters de tamaños (Wrappers directos a la API nativa)
	size_t alg_get_public_key_size(void) { return CRYPTO_PUBLICKEYBYTES; }
	size_t alg_get_secret_key_size(void) { return CRYPTO_SECRETKEYBYTES; }
	size_t alg_get_ciphertext_size(void) { return CRYPTO_CIPHERTEXTBYTES; }
	size_t alg_get_shared_secret_size(void) { return CRYPTO_BYTES; }
	
	// Generacion de claves
	int alg_keypair(unsigned char *pk, unsigned char *sk) {
		if (!is_initialized) return -1;
		return crypto_kem_keypair(pk, sk);
	}
	
	// Encapsulamiento
	int alg_encapsulate(unsigned char *ct, unsigned char *ss, const unsigned char *pk) {
		if (!is_initialized) return -1;
		return crypto_kem_enc(ct, ss, pk);
	}
	
	// Desencapsulamiento
	int alg_decapsulate(unsigned char *ss, const unsigned char *ct, const unsigned char *sk) {
		if (!is_initialized) return -1;
		return crypto_kem_dec(ss, ct, sk);
	}
\end{lstlisting}


\section{Precompilados y gestión de la aleatoriedad.}
\label{rng:win}
Para facilitar el desarrollo y el uso de los algoritmos de cifrado en un entorno de sistemas de proposito general, se ha optado por encapsular la lógica en bibliotecas estáticas (.lib). Así, el acceso a las llamadas a nivel de usuario se reduce a interactuar con un wrapper similar al del listing \ref{lst:wrapper_core}. 

Para facilitar el uso de los algoritmos y su compilación se usa un CMakeLists junto a un script de Windows. Para los tres algoritmos a estudiar se crean dos versiones:
\begin{itemize}
	\item Versión con \texttt{rng.h}: genera los secretos compartidas a partir de una semilla y sirve para generar los \acrshort{kat} para generar un archivo \texttt{.rsp} a partir de un archivo \texttt{.req}.
	\item Versión con \texttt{randombytes.h}: usando la librería del siguiente repositorio \cite{sprenkels_randombytes_2017} utilizada en el proyecto PQClean  \cite{SSR:KSSW22} para generar números aleatorios a partir de la entropía del sistema operativo.
\end{itemize}




\section{Arquitectura del Agente Criptográfico y de las comunicaciones (C++)}
Sobre la base de las librerías en C descritas anteriormente, se ha construido una capa de aplicación en C++ que integra las capacidades criptográficas con un módulo de comunicaciones serie.

\begin{landscape}
\begin{figure}[h]
	\centering
	% This resizes the diagram to fit perfectly on the page width
	\resizebox{0.95\paperwidth}{!}{%
		\begin{tikzpicture}
			
			% ---------------------------------------------------------
			% 1. DEFINE CLASSES
			% ---------------------------------------------------------
			
			% --- Interface: KeyExchange (CENTER) ---
			\begin{interface}[text width=9cm]{keyexchange}{0,0}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(inout pk: char, inout sk: char)}
				\operation{+encapsulate(inout ct: char,inout ss:char, inout pk:char)}
				\operation{+decapsulate(inout ss: char,inout ct:char, inout sk:char)}
			\end{interface}
			
			% --- Class: AlgorithmTester (LEFT) ---
			% Positioned to the left of the interface
			\begin{class}[text width=8.0cm]{AlgorithmTester}{-11, 1.2}
				\attribute{-frequency\_: long}
				\attribute{-stack\_trap: uint8\_t}
				\attribute{-STACK\_SIZE: const int}
				\attribute{-CANARY: const int}
				\attribute{-pk\_buf: vector$<$char$>$}
				\attribute{-sk\_buf: vector$<$char$>$}
				\attribute{-ct\_buf: vector$<$char$>$}
				\attribute{-ss\_buf: vector$<$char$>$}
				
				\operation{+AlgorithmTester(inout alg: KeyExchange)}
				\operation{+runStackAnalysis()}
				\operation{+runCycleAnalysis()}
				\operation{+runThroughputAnalysis()}
				\operation{+paintStack()}
				\operation{+checkStackDepth()}
				\operation{+resizeBuffers()}
			\end{class}
			
			% --- Class: KEMProtocol (RIGHT) ---
			% Positioned to the right of the interface
			\begin{class}[text width=10cm]{KEMProtocol}{13, 0.1}
				\attribute{-secret\_key\_: SecureVector}
				\attribute{-shared\_secret\_: SecureVector}
				
				\operation{+KEMProtocol(inout kem: KeyExchange, in role: ProtocolRole)}
				\operation{+getState()}
				\operation{+start\_negotiation()}
				\operation{+process\_message(in input\_msg: char)}
				\operation{+get\_shared\_secret()}
				\operation{+handle\_encapsulation(in pk: vector)}
				\operation{+handle\_decapsulation(in ct: vector)}
				\operation{+transition\_to\_error(out msg: char)}
			\end{class}
			
			% --- Datatype: SecureVector (ABOVE KEMProtocol) ---
			\begin{class}[text width=6.5cm]{SecureVector}{13, 4}
				\stereotype{datatype}
				\operation{+allocate(in n: size\_t)}
				\operation{+deallocate(inout p: classT, in n: size\_t)}
			\end{class}
			
			% --- Implementations (BOTTOM CENTER) ---
			% Fully restored methods for all three classes
			
			\begin{class}[text width=4.2cm]{Saber}{0, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			\begin{class}[text width=4.2cm]{Kyber}{-5, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			\begin{class}[text width=4.2cm]{HQC}{5, -9}
				\inherit{keyexchange}
				\operation{+get\_public\_key\_size()}
				\operation{+get\_secret\_key\_size()}
				\operation{+get\_ciphertext\_size()}
				\operation{+get\_shared\_secret\_size()}
				\operation{+get\_algorithm\_name()}
				\operation{+keypair(...)}
				\operation{+encapsulate(...)}
				\operation{+decapsulate(...)}
			\end{class}
			
			% --- Enums (BOTTOM RIGHT) ---
			% Moved down to Y=-11 to avoid overlap
			\begin{class}[text width=3cm]{ProtocolRole}{11, -11}
				\stereotype{enumeration}
				\attribute{+INITIATOR}
				\attribute{+RESPONDER}
			\end{class}
			
			\begin{class}[text width=4cm]{ProtocolState}{15, -11}
				\stereotype{enumeration}
				\attribute{+INIT}
				\attribute{+WAITING\_FOR\_CT}
				\attribute{+WAITING\_FOR\_PK}
				\attribute{+ESTABLISHED}
				\attribute{+FAILURE}
			\end{class}
			
			% ---------------------------------------------------------
			% 2. DRAW RELATIONS
			% ---------------------------------------------------------
			
			% Style for the Composition Diamond (filled black diamond)
			% "start" means the diamond is at the beginning of the line
			\tikzset{diamond_start/.style={{Diamond[fill=black, width=3mm, length=5mm]}-}}
			
			% A. AlgorithmTester <>-> KeyExchange
			% Diamond is attached to AlgorithmTester
			\draw[diamond_start] (AlgorithmTester.east) -- (keyexchange.west) 
			node[midway, above, yshift=0.5mm] {algo\_};
			
			% B. KEMProtocol <>-> KeyExchange
			% Diamond is attached to KEMProtocol
			\draw[diamond_start] (KEMProtocol.west) -- (keyexchange.east) 
			node[midway, above] {kem\_: unique\_ptr};
			
			% C. KEMProtocol <>-> ProtocolRole
			% Vertical line down, then horizontal. Diamond at KEMProtocol.
			% pos=0.1 places the text near the top (near the diamond)
			% anchor=east forces the text to sit to the LEFT of the line
			\draw[diamond_start] (KEMProtocol.south) -- ++(0,-1.5) -| (ProtocolRole.north) 
			node[pos=0.1, anchor=east, yshift=2mm] {role\_}; 
			
			% D. KEMProtocol <>-> ProtocolState
			% Vertical line down, then horizontal. Diamond at KEMProtocol.
			% pos=0.1 places the text near the top (near the diamond)
			% anchor=west forces the text to sit to the RIGHT of the line
			\draw[diamond_start] (KEMProtocol.south) -- ++(0,-1.5) -| (ProtocolState.north) 
			node[pos=0.1, anchor=west, yshift=2mm] {state\_};
			
			% E. SecureVector Association
			% Simple line, matching the diagram's placement

			
		\end{tikzpicture}%
	}
	\caption{miau}
	\label{fig:logicUML}
	
\end{figure}
\end{landscape}

\begin{figure}[H]
	\centering
	\resizebox{\textwidth}{!}{%
		\begin{tikzpicture}
			
			% ---------------------------------------------------------
			% 1. LEFT COLUMN: The "Big" Class
			% ---------------------------------------------------------
			\begin{class}[text width=9cm]{SerialComunication}{0, 0}
				\attribute{-availablePorts: vector$<$pair$<$int,wstring$>$$>$}
				\attribute{-hSerial: HANDLE}
				\attribute{-running: atomic$<$bool$>$}
				\attribute{-receiveThread: tread}
				\attribute{-receiveMutex: mutex}
				
				\operation{-setAvailablePorts()}
				\operation{-receiveLoop()}
				\operation{+SerialComunication(in bufferSize: int)}
				\operation{+updateAvailablePorts()}
				\operation{+openPort(in port:int)}
				\operation{+closePort()}
				\operation{+send(in message: str)}
				\operation{+isBufferEmpty()}
				\operation{+getReceivedMessage()}
				\operation{+startReceiving()}
				\operation{+stopReceiving()}
				\operation{+displayAvaileblePorts()}
				\operation{+getAvailablePorts()}
			\end{class}
			
			% ---------------------------------------------------------
			% 2. RIGHT COLUMN: The Stacked Classes
			% ---------------------------------------------------------
			
			% --- TOP RIGHT: SerialPacketTransport ---
			% CHANGED Y=0 to Y=5 so it sits ABOVE the center line
			\begin{class}[text width=8cm]{SerialPacketTransport}{11, 0}
				\attribute{-internalBuffer: str}
				\operation{+SerialPacketTransport(inout s: SerialComunication)}
				\operation{+sendPacket(in data: vector$<$char$>$)}
				\operation{+receivePacket(out data: vector$<$char$>$, in ms: int)}
			\end{class}
			
			% --- BOTTOM RIGHT: CircularBuffer ---
			% Y=-5 is perfect for the bottom one
			\begin{class}[text width=8cm]{CircularBuffer}{11, -4}
				\attribute{-size: int}
				\attribute{-head: int}
				\attribute{-tail: int}
				\attribute{-count: int}
				\attribute{-buffer: str}
				
				\operation{+CircularBuffer(in size: int)}
				\operation{+push(in value: str)}
				\operation{+pop(out value: str)}
				\operation{+isempty()}
				\operation{+isfull()}
				\operation{+getCount()}
				\operation{+getSize()}
			\end{class}
			
			% ---------------------------------------------------------
			% 3. CONNECTIONS
			% ---------------------------------------------------------
			
			% DEFINE THE ARROW STYLE
			% {Diamond...}-  means "Put a diamond at the START, nothing at the END"
			% ARROW STYLE: Diamond at the START of the line
			\tikzset{comp/.style={{Diamond[fill=black, width=3mm, length=5mm]}-}}
			
			% RELATION 1: Transport (Right) -> Communication (Left)
			% Diamond on Transport.
			% Draw from Transport.west -> Horizontal intersection with Communication.east
			\draw[comp] (SerialPacketTransport.west) -- (SerialPacketTransport.west -| SerialComunication.east)
			node[midway, above] {serial};
			
			% RELATION 2: Communication (Left) -> Buffer (Right)
			% Diamond on Communication.
			% Draw from Horizontal intersection on Communication.east -> Buffer.west
			\draw[comp] (CircularBuffer.west -| SerialComunication.east) -- (CircularBuffer.west)
			node[midway, above, yshift=2mm] {receiveBuffer};
			
		\end{tikzpicture}%
	}
	\caption{miau}
	\label{fig:comunicationsUML}
	
\end{figure}

\begin{figure}[H]
	% This box tells LaTeX: "Pretend this content fits in \linewidth and center it [c]"
	\makebox[\linewidth][c]{%
		\includegraphics[width=1.2\linewidth]{figuras/umlTiempo}%
	}
	\caption{miau}
	\label{fig:umltiempo}
\end{figure}
\subsection{Diagrama de Clases y Diseño del Agente}
La integración se ha modelado siguiendo un patrón de diseño orientado a objetos, donde cada algoritmo es encapsulado en una clase que hereda de una interfaz común \texttt{ICryptoProvider}. Esto permite al Agente cambiar de algoritmo dinámicamente según la configuración recibida por el puerto serie.

La Figura \ref{fig:class_diagram} ilustra la arquitectura del sistema, destacando la relación entre el gestor de comunicaciones (\texttt{SerialManager}) y el núcleo criptográfico.



\section{Implementación de algoritmos en el microcontrolador}

\section{Filosofia de comunicacion}
\section{Tests realizados}
\subsection{Ciclos de CPU}
\subsection{Throughput (Operaciones por segundo)}
\subsection{Uso de Pila (Stack Usage)}
\subsection{Tamaño del Binario (Code Size / Footprint)}
\subsection{Coste de Comunicación (Overhead)}
\subsection{Suite de aleatoriedad a randombytes}
limitaciones ent y funcionamiento \cite{ENTLimita} , dieharder \cite{brown2006dieharder}, Do1 \cite{U01test} y nist \cite{rngNistPaper}
