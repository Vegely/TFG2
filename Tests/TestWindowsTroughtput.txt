#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h> // Required for Windows High-Resolution Timers
#include "hqc_wrapper.h"

int main(void) {
    if (hqc_init(HQC_SECURITY_256) != 0) {
        fprintf(stderr, "HQC init failed\n");
        return 1;
    }

    size_t pk_size = hqc_get_public_key_size();
    size_t sk_size = hqc_get_secret_key_size();
    size_t ct_size = hqc_get_ciphertext_size();
    size_t ss_size = hqc_get_shared_secret_size();

    printf("HQC Sizes:\n");
    printf("  Public Key Size      : %zu bytes\n", pk_size);
    printf("  Secret Key Size      : %zu bytes\n", sk_size);
    printf("  Ciphertext Size      : %zu bytes\n", ct_size);
    printf("  Shared Secret Size   : %zu bytes\n\n", ss_size);

    unsigned char* pk = malloc(pk_size);
    unsigned char* sk = malloc(sk_size);
    unsigned char* ct = malloc(ct_size);
    unsigned char* ss = malloc(ss_size);

    if (!pk || !sk || !ct || !ss) {
        fprintf(stderr, "Memory allocation failed\n");
        return 1;
    }

    // Windows Timing Variables
    LARGE_INTEGER frequency; // Ticks per second
    LARGE_INTEGER start, current;
    double elapsed_seconds;
    unsigned long long count;

    // Get the CPU frequency for timing
    QueryPerformanceFrequency(&frequency);

    printf("--------------------------------------------------\n");
    printf("Starting Performance Benchmark (1 second per op)...\n");
    printf("--------------------------------------------------\n\n");


    // ===========================
    // 1. KEYPAIR GENERATION
    // ===========================
    printf("Benchmarking Keypair... ");
    count = 0;
    QueryPerformanceCounter(&start); // Start Timer

    do {
        if (hqc_keypair(pk, sk) != 0) {
            fprintf(stderr, "Keypair generation failed\n");
            break;
        }
        count++;
        QueryPerformanceCounter(&current);
        // Calculate elapsed time in seconds
        elapsed_seconds = (double)(current.QuadPart - start.QuadPart) / frequency.QuadPart;
    } while (elapsed_seconds < 1.0);

    printf("Done.\n");
    printf("-> Total Iterations: %llu\n", count);
    printf("-> Throughput      : %.2f ops/sec\n\n", count / elapsed_seconds);


    // ===========================
    // 2. ENCAPSULATION
    // ===========================
    // Note: We reuse the pk generated in the last iteration of the previous step
    printf("Benchmarking Encapsulation... ");
    count = 0;
    QueryPerformanceCounter(&start); // Start Timer

    do {
        if (hqc_encapsulate(ct, ss, pk) != 0) {
            fprintf(stderr, "Encapsulation failed\n");
            break;
        }
        count++;
        QueryPerformanceCounter(&current);
        elapsed_seconds = (double)(current.QuadPart - start.QuadPart) / frequency.QuadPart;
    } while (elapsed_seconds < 1.0);

    printf("Done.\n");
    printf("-> Total Iterations: %llu\n", count);
    printf("-> Throughput      : %.2f ops/sec\n\n", count / elapsed_seconds);


    // ===========================
    // 3. DECAPSULATION
    // ===========================
    // Note: We reuse the ct and sk from the previous steps
    printf("Benchmarking Decapsulation... ");
    count = 0;
    QueryPerformanceCounter(&start); // Start Timer

    do {
        if (hqc_decapsulate(ss, ct, sk) != 0) {
            fprintf(stderr, "Decapsulation failed\n");
            break;
        }
        count++;
        QueryPerformanceCounter(&current);
        elapsed_seconds = (double)(current.QuadPart - start.QuadPart) / frequency.QuadPart;
    } while (elapsed_seconds < 1.0);

    printf("Done.\n");
    printf("-> Total Iterations: %llu\n", count);
    printf("-> Throughput      : %.2f ops/sec\n\n", count / elapsed_seconds);


    // Cleanup
    free(pk);
    free(sk);
    free(ct);
    free(ss);

    printf("Benchmark complete. Press Enter to exit...");
    getchar();
    return 0;
}